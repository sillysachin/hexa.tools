package fr.lteconsulting.hexa.databinding.annotation.processor;

import java.io.IOException;
import java.io.Writer;
import java.util.HashSet;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.util.ElementFilter;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic.Kind;
import javax.tools.JavaFileObject;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;

import fr.lteconsulting.hexa.databinding.annotation.Observable;

@SupportedAnnotationTypes( { "fr.lteconsulting.hexa.databinding.annotation.Observable" } )
@SupportedSourceVersion( SourceVersion.RELEASE_7 )
public class ObservableAnnotationProcessor extends AbstractProcessor
{
	private Elements elementUtils;
	private Filer filer;

	@Override
	public synchronized void init( ProcessingEnvironment processingEnv )
	{
		super.init( processingEnv );

		elementUtils = processingEnv.getElementUtils();
		filer = processingEnv.getFiler();
	}

	@Override
	public boolean process( Set<? extends TypeElement> arg0, RoundEnvironment roundEnv )
	{
		if( !roundEnv.processingOver() )
		{
			final Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith( Observable.class );

			for( final TypeElement annotatedElement : ElementFilter.typesIn( annotatedElements ) )
				createObservableFor( annotatedElement );
		}
		return true;
	}

	private void createObservableFor( TypeElement factoredType )
	{
		String pkgName = elementUtils.getPackageOf( factoredType ).getQualifiedName().toString();

		String factoredTypeName = factoredType.getSimpleName().toString();

		String targetTypeName;
		String SUFFIX = "Internal";
		if( factoredTypeName.endsWith( SUFFIX ) )
			targetTypeName = capitalizeFirstLetter( factoredTypeName ).substring( 0, factoredTypeName.length() - SUFFIX.length() );
		else
			targetTypeName= "Observable" + capitalizeFirstLetter( factoredTypeName );

		try
		{
			JavaFileObject jfo = filer.createSourceFile( pkgName + "." + targetTypeName );
			Writer writer = jfo.openWriter();

			Builder builder = TypeSpec.classBuilder( targetTypeName ).addModifiers( Modifier.PUBLIC, Modifier.FINAL ).superclass(ClassName.get( factoredType ) );
			
			processConstructors( factoredType, builder );

			processFieldsAndMethods( factoredType, builder );
			
			TypeSpec target = builder.build();

			JavaFile javaFile = JavaFile.builder( pkgName, target )
					.addFileComment( "Observable class generated from {@link " + pkgName + "." + factoredTypeName + "}" )
					.addFileComment( "Generated by HexaBinding" )
					.addFileComment( "Made by LTE Consulting" )
					.build();

			javaFile.writeTo( writer );

			writer.close();
		}
		catch( IOException e )
		{
			e.printStackTrace();
			error( e.getMessage() );
		}
	}

	private void processConstructors( TypeElement factoredType, Builder builder )
	{
		for( ExecutableElement constr : ElementFilter.constructorsIn( factoredType.getEnclosedElements() ) )
		{
			if( ! constr.getModifiers().contains( Modifier.PUBLIC ) )
				continue;
			
			MethodSpec.Builder mb = MethodSpec.constructorBuilder().addModifiers( Modifier.PUBLIC );
			
			for( VariableElement parameter : constr.getParameters() )
				mb.addParameter( ClassName.get( parameter.asType() ), parameter.getSimpleName().toString() );
			
			StringBuilder body = new StringBuilder();
			body.append( "super( " );
			boolean addComa = false;
			for( VariableElement parameter : constr.getParameters() )
			{
				if( addComa)
					body.append( ", " );
				else
					addComa = true;
				body.append( parameter.getSimpleName() );
			}
			body.append( ");" );
			
			mb.addCode( body.toString() );
			
			builder.addMethod( mb.build() );
		}
	}

	private void processFieldsAndMethods( TypeElement factoredType, Builder builder )
	{
		Set<String> settersDone = new HashSet<>();
		Set<String> gettersDone = new HashSet<>();
		
		processMethods( factoredType, builder, settersDone, gettersDone );
		
		processFields( factoredType, builder, settersDone, gettersDone );
	}

	private void processMethods( TypeElement factoredType, Builder builder, Set<String> settersDone, Set<String> gettersDone )
	{
		for( ExecutableElement method : ElementFilter.methodsIn( factoredType.getEnclosedElements() ) )
		{
			String methodName = method.getSimpleName().toString();
			
			if( method.getModifiers().contains( Modifier.PRIVATE ) )
				continue;
			
			String propertyName = lowerFirstLetter(methodName.substring( 3 ));
			
			if( methodName.startsWith( "set" ) )
			{
				if( method.getModifiers().contains( Modifier.FINAL ))
					continue;
				
				Modifier[] modifiers = new Modifier[method.getModifiers().size()];
				int i=0;
				for(Modifier m : method.getModifiers())
					modifiers[i++] = m;
				
				MethodSpec setter = MethodSpec.methodBuilder(methodName)
					    .returns(void.class)
					    .addParameter( ClassName.get( method.getParameters().get( 0 ).asType() ), propertyName )
					    .addModifiers( modifiers )
					    .addStatement( "super." + methodName + "( " + propertyName + " )" )
					    .addStatement( "fr.lteconsulting.hexa.databinding.properties.Properties.notify(this, \""+propertyName+"\")")
					    .build();
				
				builder.addMethod( setter );
				settersDone.add( propertyName );
			}
			else if( methodName.startsWith( "get" ))
			{
				gettersDone.add( propertyName );
			}
		}
	}

	private void processFields( TypeElement factoredType, Builder builder, Set<String> settersDone, Set<String> gettersDone )
	{
		for( VariableElement field : ElementFilter.fieldsIn( factoredType.getEnclosedElements() ) )
		{
			if( field.getModifiers().contains( Modifier.PRIVATE ))
				continue;
			
			String propertyName = field.getSimpleName().toString();
			
			if( ! settersDone.contains( propertyName ) )
			{
				String methodName = "set" + capitalizeFirstLetter( propertyName );
				
				MethodSpec setter = MethodSpec.methodBuilder(methodName)
					    .addModifiers(Modifier.PUBLIC)
					    .returns(void.class)
					    .addParameter( ClassName.get( field.asType() ), propertyName )
					    .addStatement( "this." + propertyName + " = " + propertyName )
					    .addStatement( "fr.lteconsulting.hexa.databinding.properties.Properties.notify( this, \"" + propertyName+"\" )" )
					    .build();
				
				builder.addMethod( setter );
				settersDone.add( propertyName );
			}
			
			if( ! gettersDone.contains( propertyName ) )
			{
				String methodName = "get" + capitalizeFirstLetter( propertyName );
				
				MethodSpec getter = MethodSpec.methodBuilder(methodName)
					    .addModifiers(Modifier.PUBLIC)
					    .returns(ClassName.get( field.asType() ))
					    .addStatement("return this."+field.getSimpleName().toString())
					    .build();
				
				builder.addMethod( getter );
			}
		}
	}

	private void error( String msg )
	{
		processingEnv.getMessager().printMessage( Kind.ERROR, msg );
	}

	private static String lowerFirstLetter( String s )
	{
		return s.substring( 0, 1 ).toLowerCase() + s.substring( 1 );
	}
	
	private static String capitalizeFirstLetter( String s )
	{
		return s.substring( 0, 1 ).toUpperCase() + s.substring( 1 );
	}
}
