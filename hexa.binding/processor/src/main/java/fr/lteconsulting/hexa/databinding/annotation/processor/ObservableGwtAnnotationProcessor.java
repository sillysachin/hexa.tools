package fr.lteconsulting.hexa.databinding.annotation.processor;

import java.io.IOException;
import java.io.Writer;
import java.util.HashSet;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.util.ElementFilter;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic.Kind;
import javax.tools.JavaFileObject;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;

import fr.lteconsulting.hexa.databinding.annotation.Observable;

@SupportedAnnotationTypes( { "fr.lteconsulting.hexa.databinding.annotation.ObservableGwt" } )
@SupportedSourceVersion( SourceVersion.RELEASE_7 )
public class ObservableGwtAnnotationProcessor extends AbstractProcessor
{
	private Elements elementUtils;
	private Filer filer;
	private Types types;

	@Override
	public synchronized void init( ProcessingEnvironment processingEnv )
	{
		super.init( processingEnv );

		elementUtils = processingEnv.getElementUtils();
		filer = processingEnv.getFiler();
		types = processingEnv.getTypeUtils();
	}

	@Override
	public boolean process( Set<? extends TypeElement> arg0, RoundEnvironment roundEnv )
	{
		if( !roundEnv.processingOver() )
		{
			final Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith( Observable.class );

			for( final TypeElement annotatedElement : ElementFilter.typesIn( annotatedElements ) )
				createObservableFor( annotatedElement );
		}
		return true;
	}

	private void createObservableFor( TypeElement factoredType )
	{
		String pkgName = elementUtils.getPackageOf( factoredType ).getQualifiedName().toString();

		String factoredTypeName = factoredType.getSimpleName().toString();

		String targetTypeName;
		String SUFFIX = "Internal";
		if( factoredTypeName.endsWith( SUFFIX ) )
			targetTypeName = capitalizeFirstLetter( factoredTypeName ).substring( 0, factoredTypeName.length() - SUFFIX.length() );
		else
			targetTypeName = "Observable" + capitalizeFirstLetter( factoredTypeName );

		Templates targetClass = Templates.fromResource( "fr/lteconsulting/hexa/databinding/annotation/processor/TemplateClazzBundle.txt", 0 )
				.replace( "$SourceClassFqn", factoredType.getQualifiedName().toString() )
				.replace( "$SourceClassName", factoredType.getSimpleName().toString() )
				.replace( "$TargetClassName", targetTypeName );
		
		try
		{
			JavaFileObject jfo = filer.createSourceFile( pkgName + "." + targetTypeName );
			Writer writer = jfo.openWriter();

			Builder builder = TypeSpec.classBuilder( targetTypeName ).addModifiers( Modifier.PUBLIC, Modifier.FINAL ).superclass( ClassName.get( factoredType ) );

			targetClass.replace( "$Constructors", processConstructors( targetTypeName, factoredType, builder ) );

			targetClass.replace( "$FieldsAndMethods", processFieldsAndMethods( factoredType, builder ) );

			processTypeInfoInitializer( factoredType, targetTypeName, builder );

			TypeSpec target = builder.build();

			JavaFile javaFile = JavaFile.builder( pkgName, target ).addFileComment( "Observable class generated from {@link " + pkgName + "." + factoredTypeName + "}" ).addFileComment( "Generated by HexaBinding" ).addFileComment( "Made by LTE Consulting" ).build();

			javaFile.writeTo( writer );

			writer.close();
		}
		catch( IOException e )
		{
			e.printStackTrace();
			error( e.getMessage() );
		}
	}

	private String processConstructors( String targetTypeName, TypeElement factoredType, Builder builder )
	{
		StringBuilder result = new StringBuilder();
		
		for( ExecutableElement constr : ElementFilter.constructorsIn( factoredType.getEnclosedElements() ) )
		{
			if( !constr.getModifiers().contains( Modifier.PUBLIC ) )
				continue;
			
			Templates ctr = Templates.fromResource( "fr/lteconsulting/hexa/databinding/annotation/processor/TemplateClazzBundle.txt", 1 )
					.replace( "$TargetClassName", targetTypeName );
			
			StringBuilder formalParameters = new StringBuilder();
			boolean addComa = false;
			for( VariableElement parameter : constr.getParameters() )
			{
				String paramTypeName = ((TypeElement)(types.asElement( parameter.asType() ))).getQualifiedName().toString();
				
				if( addComa )
					formalParameters.append( ", " );
				else
					addComa = true;
				
				formalParameters.append( paramTypeName );
				formalParameters.append( " " );
				formalParameters.append( parameter.getSimpleName() );
			}
			ctr.replace( "$FormalParameters", formalParameters.toString() );
			
			StringBuilder parameters = new StringBuilder();
			addComa = false;
			for( VariableElement parameter : constr.getParameters() )
			{
				if( addComa )
					parameters.append( ", " );
				else
					addComa = true;
				parameters.append( parameter.getSimpleName() );
			}
			ctr.replace( "$Parameters", parameters.toString() );

			result.append( ctr.toString() );
		}
		
		return result.toString();
	}
	
	private String processFieldsAndMethods( TypeElement factoredType, Builder builder )
	{
		Set<String> settersDone = new HashSet<>();
		Set<String> gettersDone = new HashSet<>();

		String methods = processMethods( factoredType, builder, settersDone, gettersDone );

		String fields = processFields( factoredType, builder, settersDone, gettersDone );
		
		return methods + "\n" + fields;
	}

	private String processMethods( TypeElement factoredType, Builder builder, Set<String> settersDone, Set<String> gettersDone )
	{
		StringBuilder result = new StringBuilder();
		
		for( ExecutableElement method : ElementFilter.methodsIn( factoredType.getEnclosedElements() ) )
		{
			String methodName = method.getSimpleName().toString();

			if( method.getModifiers().contains( Modifier.PRIVATE ) )
				continue;

			String propertyName = lowerFirstLetter( methodName.substring( 3 ) );

			if( methodName.startsWith( "set" ) )
			{
				if( method.getModifiers().contains( Modifier.FINAL ) )
					continue;

				Templates setter = Templates.fromResource( "fr/lteconsulting/hexa/databinding/annotation/processor/TemplateClazzBundle.txt", 3 );
				
				StringBuilder modifiersBuilder = new StringBuilder();
				Modifier[] modifiers = new Modifier[method.getModifiers().size()];
				int i = 0;
				for( Modifier m : method.getModifiers() )
					modifiersBuilder.append( m.toString() );
				setter.replace( "$Modifiers", modifiersBuilder.toString() );
				
				setter.replace( "$MethodName", methodName );
				
				setter.replace( "$PropertyClass", ((TypeElement)(method.getParameters().get( 0 ).asType())).getQualifiedName().toString() );
				setter.replace( "$Property", propertyName );
				
				result.append( setter.toString() );
				settersDone.add( propertyName );
			}
			else if( methodName.startsWith( "get" ) )
			{
				gettersDone.add( propertyName );
			}
		}
		
		return result.toString();
	}

	private void processFields( TypeElement factoredType, Builder builder, Set<String> settersDone, Set<String> gettersDone )
	{
		for( VariableElement field : ElementFilter.fieldsIn( factoredType.getEnclosedElements() ) )
		{
			if( field.getModifiers().contains( Modifier.PRIVATE ) )
				continue;

			String propertyName = field.getSimpleName().toString();

			if( !settersDone.contains( propertyName ) )
			{
				String methodName = "set" + capitalizeFirstLetter( propertyName );

				MethodSpec setter = MethodSpec.methodBuilder( methodName ).addModifiers( Modifier.PUBLIC ).returns( void.class ).addParameter( ClassName.get( field.asType() ), propertyName ).addStatement( "this." + propertyName + " = " + propertyName )
						.addStatement( "fr.lteconsulting.hexa.databinding.properties.Properties.notify( this, \"" + propertyName + "\" )" ).build();

				builder.addMethod( setter );
				settersDone.add( propertyName );
			}

			if( !gettersDone.contains( propertyName ) )
			{
				String methodName = "get" + capitalizeFirstLetter( propertyName );

				MethodSpec getter = MethodSpec.methodBuilder( methodName ).addModifiers( Modifier.PUBLIC ).returns( ClassName.get( field.asType() ) ).addStatement( "return this." + field.getSimpleName().toString() ).build();

				builder.addMethod( getter );
			}
		}
	}

	private void processTypeInfoInitializer( TypeElement factoredType, String targetClassName, Builder builder )
	{
		

		String bundleName = factoredType.getSimpleName() + "_ClazzBundle";
		TypeSpec bundleSpec = TypeSpec.interfaceBuilder( bundleName ).addMethod( MethodSpec.methodBuilder( "register" ).addAnnotation( AnnotationSpec.builder( ClassName.bestGuess( "ReflectedClasses" ) ).build() ).build() ).build();
		builder.addType( bundleSpec );
	}

	private void error( String msg )
	{
		processingEnv.getMessager().printMessage( Kind.ERROR, msg );
	}

	private static String lowerFirstLetter( String s )
	{
		return s.substring( 0, 1 ).toLowerCase() + s.substring( 1 );
	}

	private static String capitalizeFirstLetter( String s )
	{
		return s.substring( 0, 1 ).toUpperCase() + s.substring( 1 );
	}
}
